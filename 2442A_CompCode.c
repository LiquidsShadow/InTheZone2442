#pragma config(Sensor, in1,    mainLiftPot,    sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  greenLED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  redLED,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  driverSkillsJumper, sensorDigitalIn)
#pragma config(Sensor, dgtl9,  rightQuad,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, leftQuad,       sensorQuadEncoder)
#pragma config(Motor,  port1,           mainLiftRight, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveRightBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           driveRightFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           driveLeftBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           mblRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           driveLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           mainLiftLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           topLift,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mblLeft,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

static const short POT_DZ = 50;
static const int MBL_OUT_TIME = 2000; // mbl move out time (ms)
static const int MBL_OUT_TIME_HOLDING = 2100;
static const int MBL_IN_TIME = 2250; // mbl move in time (ms)
static const int TOP_LIFT_UP = 600;
static const int TOP_LIFT_DOWN = 600;
static const int LEFT = -1;
static const int RIGHT = 1;
//static int auton_side = 0; // jumper settings: left 0 right 1
//static int auton_5_10_zone = 0; // jumper settings: five 0 ten 1
//static int auton_20_zone = 0; // jumper settings: (20) off 0 on 1
static unsigned int ml_wait_time = 0; // wait time for use in tasks

// gyro: http://www.robotc.net/blog/2011/10/13/programming-the-vex-gyro-in-robotc/
// jumpers: https://renegaderobotics.org/vex-sensors-jumper-clips-led-indicators/
// lcd: http://www.robotc.net/blog/2012/05/18/advanced-applications-with-the-vex-lcd/

enum AutonScore {
	FIVE, TEN, TWENTY
};

int side = -1;
AutonScore score;

// task state monitoring variables
bool placingCone = false;
bool goingOut = false;
bool intakingMBL = false;
bool encodersStuck = false;
int monitoringTime = 0;
// auton settings
bool skipAuton = false;
bool progSkills = false;
const short BTN_LEFT = 1;
const short BTN_CENTER = 2;
const short BTN_RIGHT = 4;
const short SELECTIONS = 8;
string textDisplays[SELECTIONS] = {
	"No autonomous",
	"5 Pt. Zone [L]",
	"5 Pt. Zone [R]",
	"10 Pt. Zone [L]",
	"10 Pt. Zone [R]",
	"20 Pt. Zone [L]",
	"20 Pt. Zone [R]",
	"Prog. Skills"
};

/*
Sets the left drive to a power

@param pwr
integer value of new motor power
*/
void setLeftDrivePower(int pwr) {
	const float K = 1;
	motor[driveLeftFront] = K * pwr;
	motor[driveLeftBack] = K * pwr;
}

/*
Sets the right drive to a power

@param pwr
integer value of new motor power
*/
void setRightDrivePower(int pwr) {
	motor[driveRightFront] = pwr;
	motor[driveRightBack] = pwr;
}

/**
Sets the drive to a power

@param pwr
integer value of new motor power
*/
void setAllDriveMotors(int pwr) {
	setLeftDrivePower(pwr);
	setRightDrivePower(pwr);
}

void slewCtrlDrive(int power) {
	int current = 0;
	while (current < power) {
		current += sgn(power) * 20;
		if (current > power)
			current = power;
		setAllDriveMotors(power);
	}
}

void setMainLiftPower(int pwr) {
	motor[mainLiftRight] = pwr;
	motor[mainLiftLeft] = pwr;
}

/**
Sets the mobile base lift to a power

@param pwr
integer value of new motor power
*/
void setMBLPower(int pwr) {
	motor[mblLeft] = pwr;
	motor[mblRight] = pwr;
}

/**
Drives a distance and proportionally decreases motor power

@param ticks
integer value of encoder ticks to travel
*/
void drive(int ticks, int timeStopMS = 100000, bool startSlewed = false) {
	clearTimer(T4);
	//	const int K_TURN = 0.5;
	const int K_LDRV = 2.0; // Left drive
	const int K_RDRV = 2.0;	// Right drive
	//const int START_GYRO = SensorValue[gyro];
	SensorValue[leftQuad] = 0;
	SensorValue[rightQuad] = 0;
	//int turnErr = SensorValue[gyro] - START_GYRO;
	int distLeft = ticks - SensorValue[leftQuad];
	int distRight = ticks - SensorValue[rightQuad];
	int pwrL = (int) (distLeft * K_LDRV); // - K_TURN * turnErr);
	int pwrR = (int) (distRight * K_RDRV); // + K_TURN * turnErr);
	if (startSlewed)
		slewCtrlDrive(sgn(ticks) * 127);
	while (fabs(distLeft) > 25 && fabs(distRight) > 25 && time1[T4] < timeStopMS) {
		//turnErr = SensorValue[gyro] - START_GYRO;
		distLeft = ticks - SensorValue[leftQuad];
		distRight = ticks - SensorValue[rightQuad];
		pwrL = (int) (distLeft * K_LDRV);// - K_TURN * turnErr);
		pwrR = (int) (distRight * K_RDRV);  // + K_TURN * turnErr);
		setLeftDrivePower(pwrL);
		setRightDrivePower(pwrR);
		//writeDebugStreamLine("Power Left: %i", pwrL);
		//writeDebugStreamLine("Power Right: %i", pwrR);
		//writeDebugStreamLine("Turn: %i", (int) (K_TURN * turnErr));
	}
	setAllDriveMotors(0);
}

//*********************************DEPRECATED**********************************************

/**
turns the robot by a number of ticks (Prop. )

@param ticks
distance in encoder ticks

- If ticks < 0 => left
- If ticks > 0 => right
*/
void turnV2(int ticks) {
	SensorValue[leftQuad] = 0;
	SensorValue[rightQuad] = 0;
	const float TURN_CONV = 0.95;
	/*
	While the robot has not reached its destination
	- update loop variables
	- proportionally decrease motor powers
	*/
	int dist = 0;
	while (fabs(dist) > 25) {
		if (sgn(ticks) == -1) { // if turning left => update right motors
			dist = ticks + SensorValue[leftQuad];
			setLeftDrivePower((int) (dist * TURN_CONV));
			setRightDrivePower((int) (-1 * dist * TURN_CONV));
			writeDebugStreamLine("Left drive motor power: %i", (int) (dist * TURN_CONV));
			writeDebugStreamLine("Right drive motor power: %i", (int) (-1 * dist * TURN_CONV));
		}
		else { // if rightQuad right => update left motors
			dist = ticks + SensorValue[rightQuad];
			setRightDrivePower(dist * TURN_CONV);
			setLeftDrivePower(-1 * dist * TURN_CONV);
			writeDebugStreamLine("Left drive motor power: %i", (int) (-1 * dist * TURN_CONV));
			writeDebugStreamLine("Right drive motor power: %i", (int) (dist * TURN_CONV));
		}
	}
	setAllDriveMotors(0); // clean
}

//*****************************************************************************************************

/**
Turns proportionally by tenths of a degree using the gyroscope

@param degrees10
tenths of a degree for which the gyro has to turn
*/
void turn(int degrees10) {
	const float Kt = 0.25; // turn gain
	int dist = degrees10 - SensorValue[in2];
	int pwr = (int) (dist * Kt);
	while (fabs(pwr) > 5)
	{
		dist = degrees10 - SensorValue[in2];
		pwr = (int) (dist * Kt); // RECALIBRATE
		//pwr = 127;
		writeDebugStreamLine("%i", pwr);
		setRightDrivePower(pwr);
		setLeftDrivePower(-pwr);
	}
	setMBLPower(0);
}

void turnV3(int degrees, int timeStopMS = 100000, bool doCorrection = false) {
	clearTimer(T4);
	const int DEGREES10 = degrees * 10;
	const float Kt = 0.25;
	const int GYRO_START = SensorValue[in2];
	const int TARGET = (fabs(GYRO_START + DEGREES10) > 3600) ? (sgn(degrees) * (fabs(GYRO_START + DEGREES10) - 3600)) : (GYRO_START + DEGREES10);
	int dist = TARGET - SensorValue[in2];
	int pwr = (int) (dist * Kt);
	while (fabs(pwr) > 5 && time1[T4] < timeStopMS) {
		dist = TARGET - SensorValue[in2];
		pwr = (int) (dist * Kt);
		setRightDrivePower(pwr);
		setLeftDrivePower(-pwr);
	}
	setAllDriveMotors(0);
	if (doCorrection) {
		writeDebugStreamLine("Attempting Correction");
		int dist = degrees - SensorValue[gyro];
		while (fabs(dist) > 10) {
			dist = degrees - SensorValue[gyro];
			setRightDrivePower(sgn(dist) * 30);
			setLeftDrivePower(-sgn(dist) * 30);
			writeDebugStreamLine("Right Drive: %i", sgn(dist) * 30);
			writeDebugStreamLine("Left power %i", -sgn(dist) * 30);
		}
		setAllDriveMotors(0);
	}
}

/**
Moves the lift proportionally to a potentiometer position

@param pos
potentiometer position
*/
void mainLiftToPos(int pos) {
	const float Kd = -0.6; // constant for going down
	unsigned int curr = SensorValue[mainLiftPot];
	int dist = pos - curr;
	float pwr = 0;
	if (fabs(dist) > 20) {
		pwr = Kd * dist;
	}
	else
		pwr = 0;
	//writeDebugStreamLine("power: %i", pwr);
	setMainLiftPower((int) pwr);
}


// moves mobile base lift out
void mblOut(int time = MBL_OUT_TIME) {
	setMBLPower(-127);
	wait1Msec(time);
	setMBLPower(0);
}

// task for moving mobile base lift out
task mblOutTask {
	goingOut = true;
	mblOut();
	goingOut = false;
}

// moves mobile base lift in
void mblIn() {
	setMBLPower(127);
	wait1Msec(MBL_IN_TIME);
	setMBLPower(0);
	//writeDebugStreamLine("HELLLLLLLLLLLLLLO");
}

// task for moving mobile base lift in
task mblInTask {
	intakingMBL = true;
	mblIn();
	intakingMBL = false;
}

/**
method that combines mblOutTask and driving some distance in encoder ticks

@param ticks
integer value of encoder ticks to travel
@param wait
wait default to 0
*/
void driveAndMBLOut(int ticks, int wait = 0) {
	startTask(mblOutTask);
	wait1Msec(wait);
	drive(ticks);
}

/*
method that combines mblInTask and driving some distances in encoder ticks

@param ticks
encoder ticks to drive
*/
void driveAndMBLIn(int ticks) {
	startTask(mblInTask);
	wait1Msec(MBL_IN_TIME/2);
	drive(ticks);
}

// task for moving main lift up
task mainLiftUp() {
	setMainLiftPower(-127);
	wait1Msec(ml_wait_time);
	setMainLiftPower(0);
}

void placeCone() {
	int cone1 = 900;
	int clearCone1 = 1500;
	placingCone = true;
	while (SensorValue[mainLiftPot] > cone1 + POT_DZ)
		mainLiftToPos(cone1);
	motor[intake] = -127;
	wait1Msec(100);
	motor[intake] = -40;
	placingCone = false;
	writeDebugStreamLine("Hello?");
	while (SensorValue[mainLiftPot] < clearCone1 - POT_DZ)
		mainLiftToPos(clearCone1);
	setMainLiftPower(0);
	motor[intake] = 0;
}

void topLiftUp() {
	motor[topLift] = -100;
	wait1Msec(TOP_LIFT_UP);
	motor[topLift] = 0;
}

void topLiftDown() {
	motor[topLift] = 127;
	wait1Msec(TOP_LIFT_DOWN);
	motor[topLift] = 0;
}

task topLiftUpTask {
	topLiftUp();
}

task topLiftDownTask {
	topLiftDown();
}

void pickUpCone() {
	int cone2 = 950;
	int clearCone2 = 1300;
	startTask(topLiftDownTask);
	while (SensorValue[mainLiftPot] > cone2 + POT_DZ)
		mainLiftToPos(cone2);
	motor[intake] = 127;
	wait1Msec(500);
	motor[intake] = 20;
	startTask(topLiftUpTask);
	while (SensorValue[mainLiftPot] < clearCone2 - POT_DZ)
		mainLiftToPos(clearCone2);
}

task placeCone1Task() {
	placeCone();
}

void driveAndPlaceCone1(int ticks, int wait=0) {
	startTask(placeCone1Task);
	//while (placingCone) {}
	wait1Msec(100);
	drive(ticks);
}

// task for placing cone: lowers lift down and then releases cone and raises lift up
task placeConeByTime {
	setMainLiftPower(127);
	wait1Msec(ml_wait_time);
	setMainLiftPower(0);
	setMainLiftPower(-127);
	wait1Msec(250);
	setMainLiftPower(-127);
	wait1Msec(ml_wait_time);
	setMainLiftPower(0);
	motor[intake] = 0;
}

/**
method that combines mainLiftUp and driving some distance in encoder ticks

@param ticks
integer value of encoder ticks to travel
@param n
value passed to global variable used in main lift task
*/
void driveAndRaiseMainLift(int ticks, int n) {
	ml_wait_time = n;
	startTask(mainLiftUp);
	drive(ticks);
}

/*
Drives and places a cone on a mobile goal

@param ticks
encoder ticks to drive
@param n
wait time n
*/
void driveAndPlaceCone(int ticks, int n) {
	ml_wait_time = n;
	startTask(placeConeByTime);
	drive(ticks);
}

// *******************************************DEPRECATED*****************************************************
void setPincerPower(int pincerPower) {
	//motor[leftPincer] = pincerPower;
	//motor[rightPincer] = pincerPower;
}

/**
Sets pincer to a position (Prop.)
@param pincerPos - a position
*/
void setPinToPos(int pos) {
	const float PINC_CONV = 0.225; // Pincer Conversion
	static const int PINC_POT = 30; // Pincer Buffer Zone
	//int dist = pos - SensorValue[pincerPot];

	/*
	if (fabs(dist) > PINC_POT)
	{
	int pwr = -dist * PINC_CONV;
	setPincerPower(pwr);
	}
	else {
	setPincerPower(0); // clean
	} */
}

task pincToPos() {
	//for (unsigned int i = 0; i < pincerWait; i++)
	//setPinToPos(pincerPos);
}

// ***********************************************************************************************************

task displayBatLvl() {
	string mainBatLvl = "", backUpBatLvl = "";
	while (true) {
		displayLCDCenteredString(0, "Main Bat. Lvl.");
		sprintf(mainBatLvl, "%1.2f%c", nAvgBatteryLevel/1000, 'V');
		displayLCDCenteredString(1, mainBatLvl);
		wait1Msec(3500);
		displayLCDCenteredString(0, "Backup Bat. Lvl.");
		sprintf(backUpBatLvl, "%1.2f%c", BackupBatteryLevel/1000,'V');
		displayLCDCenteredString(1, backUpBatLvl);
		wait1Msec(3600);
	}
}

void waitForPress() {
	while (nLCDButtons == 0) {}
	wait1Msec(5);
}

void waitForRelease() {
	while (nLCDButtons != 0) {}
	wait1Msec(5);
}

bool leftPressed() {
	return nLCDButtons == BTN_LEFT;
}

bool centerPressed() {
	return nLCDButtons == BTN_CENTER;
}

bool rightPressed() {
	return nLCDButtons == BTN_RIGHT;
}

// *******************************************DEPRECATED*****************************************************


int lcdUI() {
	clearLCDLine(0);
	clearLCDLine(1);
	int selection = 0;
	while (!centerPressed()) {
		displayLCDCenteredString(0, textDisplays[selection]);
		displayLCDCenteredString(1, "<    Enter     >");
		if (selection == 0) {
			if (leftPressed()) {
				waitForRelease();
				selection = SELECTIONS - 1;
			}
			else if (rightPressed()) {
				waitForRelease();
				selection++;
			}
		}
		else if (selection == SELECTIONS - 1) {
			if (leftPressed()) {
				waitForRelease();
				selection--;
			}
			else if (rightPressed()) {
				waitForRelease();
				selection = 0;
			}
		}
		else {
			if (leftPressed()) {
				waitForRelease();
				selection--;
			}
			else if (rightPressed()) {
				waitForRelease();
				selection++;
			}
		}
	}
	writeDebugStreamLine(textDisplays[selection]);
	return selection;
}

// ***************************************1******************************************************************

int lcdUI2() {
	clearLCDLine(0);
	clearLCDLine(1);
	int selection = 0;
	bool done = false;
	while (!done) {
		displayLCDCenteredString(0, textDisplays[selection]);
		displayLCDCenteredString(1, "<    Enter     >");
		waitForPress();
		if (leftPressed()) {
			waitForRelease();
			if (selection == 0)
				selection = SELECTIONS - 1;
			else
				selection--;
		}
		else if (rightPressed()) {
			waitForRelease();
			if (selection == SELECTIONS - 1)
				selection = 0;
			else
				selection++;
		}
		else if (centerPressed()) {
			waitForRelease();
			done = true;
		}
	}
	writeDebugStreamLine(textDisplays[selection]);
	return selection;
}

void setUpAuton() {
	int choice = lcdUI2();
	skipAuton = choice == 0;
	progSkills = choice == SELECTIONS - 1;
	side = (choice % 2 == 0) ? (LEFT) : (RIGHT);
	if (choice == 1 || choice == 2)
		score = FIVE;
	else if (choice == 3 || choice == 4)
		score = TEN;
	else if (choice == 5 || choice == 6)
		score = TWENTY;
}

// ***************************************1****DEPRECATED*****************************************************

void loadFromJumpers() {
	//runPS20();
	/*
	if (auton_5_10_zone == 1)
	{
	if (auton_20_zone == 0) {
	writeDebugStreamLine("20 Zone Auton Initiated.. ");
	_20auton();
	}
	else {
	writeDebugStreamLine("5 point");
	_5auton();
	}
	}
	else if (auton_5_10_zone == 0) {
	writeDebugStreamLine("10 Zone Auton Initiated.. ");
	_10auton();
	}
	else {
	writeDebugStreamLine("No autonomous point zone selected.");
	writeDebugStreamLine("Running 5 point autonomous on left side by default.");
	}
	writeDebugStreamLine("Side: %i", auton_side);
	*/
}

// ******************************************************************************************************

task autonTestTask {
	clearTimer(T3);
	writeDebugStreamLine("--AUTON TIMER STARTED--");
	while (time1[T3] < 15001) { }
	setAllDriveMotors(0);
	setMBLPower(0);
	setMainLiftPower(0);
	motor[topLift] = 0;
	motor[intake] = 0;
	writeDebugStreamLine("--AUTON STOPPED--");
}


// runs 5 point autonomous; scores in corner (target 5 point zone)
void _5auton() {
	displayLCDCenteredString(0, "Running 5 pt.");
	clearTimer(T1);
	motor[intake] = 40;
	startTask(mblOutTask);
	driveAndRaiseMainLift(1400, 500);
	stopTask(mblOutTask);
	driveAndMBLIn(200);
	while (intakingMBL) {}
	placeCone();
	pickUpCone();
	drive(-1300);
	//turn(side * 2000);
	turnV3(side * 200);
	mblOut(MBL_OUT_TIME_HOLDING);
	drive(-1500);
	writeDebugStreamLine("5 Zone Auton Time (msec): %d", time1[T1]);
}

void _5autonV2() {
	displayLCDCenteredString(0, "Running 5 pt.");
	clearTimer(T1);
	motor[intake] = 40;
	startTask(mblOutTask);
	driveAndRaiseMainLift(1500, 500);
	while (goingOut) {}
	driveAndMBLIn(100);
	while (intakingMBL) {}
	placeCone();
	int mark1 = time1[T1];
	pickUpCone();
	driveAndPlaceCone1(-1500);
	int mark2 = time1[T1];
	turnV3(side * 100);
	drive(100);
	turnV3(side * 100);
	mblOut();
	drive(-300);
	writeDebugStreamLine("5 Zone Auton Time (msec): %d", time1[T1]);
	writeDebugStreamLine("Cone stacking time: %d", mark2-mark1);
}

void _10auton() {
	//startTask(autonTestTask);
	displayLCDCenteredString(0, "Running 10 pt.");
	clearTimer(T1);
	motor[intake] = 40;
	startTask(mblOutTask);
	driveAndRaiseMainLift(1500, 500);
	while (goingOut) {}
	driveAndMBLIn(100);
	while (intakingMBL) {}
	placeCone();
	int mark1 = time1[T1];
	pickUpCone();
	driveAndPlaceCone1(-1500);
	int mark2 = time1[T1];
	//turn(side * 2100);
	turnV3(side * 110);
	drive(100);
	turnV3(side * 100);
	driveAndMBLOut(400, 500);
	while(goingOut) {}
	drive(-300);
	writeDebugStreamLine("10 Zone Auton Time (msec): %d", time1[T1]);
	writeDebugStreamLine("Cone stacking time: %d", mark2-mark1);
}

void _20auton() {
	displayLCDCenteredString(0, "Running 20 pt.");
	clearTimer(T1);
	//setLeftDrivePower(100);
	//wait1Msec(100);
	//setLeftDrivePower(0);
	motor[intake] = 40;
	startTask(mblOutTask);
	driveAndRaiseMainLift(1500, 500);
	//driveAndMBLIn(200);
	//while (intakingMBL) {}
	while (goingOut) {}
	mblIn();
	driveAndPlaceCone1(-1400);
	turnV3(side * 130);
	drive(500);
	turnV3(side * 90);
	drive(300);
	driveAndMBLOut(500, 500);
	while(goingOut) {}
	drive(-500);
	writeDebugStreamLine("20 Zone Auton Time (msec): %d", time1[T1]);
}
// runs 10 point autonomous scores in corner (target 10 point zone)
void _20autonV2() {
	displayLCDCenteredString(0, "Running 10 pt.");
	clearTimer(T1);
	motor[intake] = 40;
	startTask(mblOutTask);
	driveAndRaiseMainLift(1600, 500);
	driveAndMBLIn(-400);
	driveAndPlaceCone(-900, 1000);
	turn(side * 1800);
	drive(300);
	turn(side * 2900);
	drive(300);
	mblOut();
	drive(-2000);
	writeDebugStreamLine("10 Zone Auton Time (msec): %d", time1[T1]);
}
// runs 20 point autonomous; scores in middle (target 20 point zone)
void _20autonV3() {
	displayLCDCenteredString(0, "Running 20 pt.");
	clearTimer(T1);
	motor[intake] = 40;
	startTask(mblOutTask);
	driveAndRaiseMainLift(1600, 500);
	driveAndMBLIn(20);
	driveAndPlaceCone(-1000, 1000);
	turn(side * 1800);
	drive(750);
	turn(side * 2900);
	drive(800);
	mblOut();
	drive(-500);
	writeDebugStreamLine("20 Zone Auton Time (msec): %d", time1[T1]);
}

// start with 20 point auton (target score: 72)
void runPS20() {
	clearTimer(T1);
	_20auton();
	turn(-1900);
	drive(400);
	turn(-700);
	drive(1000);
	driveAndMBLIn(-1300);
	turn(1600);
	drive(100);
	mblOut();
	drive(-1000);
	turn(800);
	drive(800);
	driveAndMBLIn(200);
	turn(1800);
	drive(1500);
	mblOut();
	setMBLPower(-127);
	wait1Msec(250);
	setMBLPower(0);
	drive(-500);
	turn(900);
	drive(100);
	turn(-200);
	drive(1700);
	driveAndMBLIn(1400);
	mblOut();
	drive(-500);
	writeDebugStreamLine("Programming Skills start with 20 point auton time: ", time1[T1]);
}

void runProgSkills() {
	clearTimer(T1);
	_20auton();
	// Target Score: 22
	turnV3(80); // turn
	drive(-775); // drive backward
	turnV3(45); // turn to line approx. up with wall
	drive(-425, 1500); // back up to wall (attempt to align)
	drive(450); // drive away from wall
	turnV3(40); // turn to face mbg
	drive(600); // drive to mbg
	mblIn(); // pick up mbg
	turnV3(190); // turn to score
	drive(900); // drive forward to bar
	driveAndMBLOut(200); // score
	while (goingOut) {}
	// Target Score: 32
	drive(-300);
	turnV3(90); // turn
	drive(-475); // drive backward
	turnV3(45);
	drive(-500, 1000);// drive backward
	drive(450);
	turnV3(40); // turn to face mbg
	drive(1800); // drive across to next mbg
	mblIn(); // pick up next mbg
	while (intakingMBL) {}
	//turnV3(-140);
	//drive(-800);
	//drive(50);
	//turnV3(45);
	//drive(500);
	//turnV3(90);
	drive(750); // drive to scoring zone
	turnV3(-90); // turn to be inline with bar
	drive(500); // drive forward
	turnV3(90); // turn to line up with goal
	drive(500); // drive toward goal
	driveAndMBLOut(400, 700); // score mbg
	while(goingOut) {}
	drive(-300, 1500); //  back out
	turnV3(45); // turn to line up with parking zone
	drive(-2000); // drive to parking spot
	writeDebugStreamLine("Prog. Skills: %d", time1[T1]/1000);
}

void loadFromLCD() {
	if (!skipAuton) {
		if (!progSkills) {
			switch (score) {
			case FIVE :
				writeDebugStreamLine("5 Point Zone Auton Initiated; Side: %i", side);
				//_5auton();
				_5autonV2();
				break;
			case TEN :
				writeDebugStreamLine("10 Point Zone Auton Initiated; Side: %i", side);
				_10auton();
				break;
			case TWENTY :
				writeDebugStreamLine("20 Point Zone Auton Initiated; Side: %i", side);
				_20auton();
				break;
			default :
				break;
			}
		}
		else {
			writeDebugStreamLine("Programming Skills Initiated; Side: %i", side);
			runProgSkills();
			//runPS20();
		}
	}
}


// runs pre auton functions set up LEDs, gyro, and read autonomous settings chosen by user using jumpers
void pre_auton() {
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	writeDebugStreamLine("Turning off LEDs.. ");
	SensorValue[redLED] = 0;
	SensorValue[greenLED] = 0;
	/*
	if (SensorValue(dgtl4) == 1)
	auton_side = -1;
	else
	auton_side = 1;
	auton_5_10_zone = SensorValue(dgtl5);
	auton_20_zone = SensorValue(dgtl6);
	*/
	writeDebugStreamLine("Reading Autonomous Settings.. ");
	SensorValue[greenLED] = 1;
	//setUpAuton();
	SensorValue[greenLED] = 0;
	writeDebugStreamLine("Initiated Gyro Calibration.. ");
	displayLCDCenteredString(0, "Gyro is");
	displayLCDCenteredString(1, "calibrating");
	SensorValue[redLED] = 1;
	SensorType[in2] = sensorNone;
	wait1Msec(1000);
	SensorType[in2] = sensorGyro;
	wait1Msec(2000);
	SensorScale[in2] = 133;
	writeDebugStreamLine("Completed Gyro Calibration.. ");
	displayLCDCenteredString(0, "Calibration");
	displayLCDCenteredString(1, "complete.");
	SensorValue[redLED] = 0;
}

// autonomous based on jumper settings that have been passed on to global variables in pre_auton()
task autonomous {
	//loadFromJumpers();
	//loadFromLCD();
	//side = -1;
	//_5autonV2();
	//_10auton();
	_20auton();
	//runProgSkills();
}


// user control
task usercontrol {
	startTask(displayBatLvl);
	bool runIntake = false;
	bool doingDriverSkills = SensorValue[driverSkillsJumper] == 0;
	while(true) {
		int rightJoy = vexRT[Ch2];
		int leftJoy = vexRT[Ch3];
		word rightTriggerUp = vexRT[Btn6U]; // main lift up
		word rightTriggerDown = vexRT[Btn6D]; // main lift down
		word leftTriggerUp = vexRT[Btn5U]; // top lift up
		word leftTriggerDown = vexRT[Btn5D]; // top lift down
		word leftPadUp = vexRT[Btn7U]; // test auton
		word leftPadDown = vexRT[Btn7D]; // automated stacking
		word rightPadUp = vexRT[Btn8U]; // mbl out
		word rightPadDown = vexRT[Btn8D]; // mbl in
		word rightPadRight = vexRT[Btn8R]; // intake in
		word rightPadLeft = vexRT[Btn8L]; // intake out

		if(fabs(leftJoy) > 15)
			setLeftDrivePower(leftJoy);
		else
			setLeftDrivePower(0);
		if(fabs(rightJoy) > 15)
			setRightDrivePower(rightJoy);
		else
			setRightDrivePower(0);

		if (doingDriverSkills) {
			if (leftTriggerUp == 1)
				setMBLPower(127);
			else if (leftTriggerDown == 1)
				setMBLPower(-127);
			else
				setMBLPower(0);
		}
		else {
			if(rightPadDown == 1)
				setMBLPower(-127);
			else if(rightPadUp == 1)
				setMBLPower(127);
			else
				setMBLPower(0);
		}

		if(rightTriggerUp == 1)
			mainLiftToPos(2100);
		//setMainLiftPower(-127);
		else if(rightTriggerDown == 1)
			mainLiftToPos(0);
		//setMainLiftPower(127);
		else
			setMainLiftPower(0);

		if (!doingDriverSkills) {
			if (leftTriggerUp == 1)
				motor[topLift] = -100;
			else if (leftTriggerDown == 1)
				motor[topLift] = 127;
			else
				motor[topLift] = 0;
		}

		if (!doingDriverSkills) {
			if(rightPadRight == 1) {
				motor[intake] = 127;
				runIntake = true;
			}
			else if(rightPadLeft == 1) {
				motor[intake] = -127;
				runIntake = false;
			}
			else {
				if (runIntake)
					motor[intake] = 20;
				else
					motor[intake] = 0;
			}
		}

		if (leftPadUp == 1) {
			//driveAndPlaceCone(1400, 1000);
			//turn(2700);
			//driveAndMBLIn(400);
			//motor[intake] = 40;
			//placeCone();
			//pickUpCone();
			//turn(1800);
			//mblOut();
			//startTask(mblOutTask);
			//mblIn();
			//turn(1800);
			//turnV3(180, true);
			//drive(2000);
		}

		if (leftPadDown == 1) {
			if (doingDriverSkills) {
				placeCone();
			}
		}



	}
}
