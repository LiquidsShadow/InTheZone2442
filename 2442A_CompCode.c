#pragma config(Sensor, in2,    mainLiftPot,    sensorPotentiometer)
#pragma config(Sensor, in3,    pincerPot,      sensorPotentiometer)
#pragma config(Sensor, dgtl9,  leftQuad,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightQuad,      sensorQuadEncoder)
#pragma config(Motor,  port1,           mobileBaseLiftRight, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mobileBaseLiftLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           pincers,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           mainLiftRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mainLiftLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           driveLeftBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           driveLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveRightFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveRightBack, tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

// Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

const float ML_CONV = 0.85; // Main Lift Conversion
const float MBL_CONV = 0.15; // Mobile Base Lift Conversion
const float PINC_CONV = 0.75; // Pincer Conversion
const float DRIVE_CONV_R = 1.0; // Right Drive Conversion
const float DRIVE_CONV_L = 0.65; // Left Drive Conversion
const float DRIVE_EN = 10.0; // Drive Encoder buffer zone
const float LIFT_POT = 5.0; // Lift Poten buffer zone
const float PINC_POT = 5.0; // Pincer Poten buffer zone
const int JOY = 15; // Joystick dead zone

static int liftPos = 0; // Global Variable for use in lift task
static int wait = 0; // Global Variable for use in mobile base lift task

enum CTRL_POS {MLU = 0, MLD = 0, MBLU = 0, MBLD = 0, PIN_O = 1960, PIN_C = 300}; // Control positions for lifts and pincers

/**
Sets left drive motors to a power.
@param pwr -	a power
*/
void setLeftMotors(int pwr)
{
	motor[driveLeftBack] = pwr;
	motor[driveLeftFront] = pwr;
}
/**
Sets right drive motors to a power.
@param pwr - a power
*/
void setRightMotors(int pwr)
{
	motor[driveRightBack] = pwr;
	motor[driveRightFront] = pwr;
}
/**
Sets both right and left motors to a power
@param pwr - a power
*/
void setAllDriveMotors(int pwr)
{
	setLeftMotors(pwr);
	setRightMotors(pwr);
}

/**
Sets drive encoders to 0
*/
void initEn()
{
	SensorValue[leftQuad] = 0;
	SensorValue[rightQuad] = 0;
}

/**
Drives for a distance and goes from 127 -> 0
@param ticks - distance in encoder ticks
- If ticks < 0 => reverse
- If ticks > 0 => forwards
!warning - drives at max power until it reaches destination: could stall motors
*/
void driveBasic(int ticks)
{
	initEn();

	int distR = ticks;
	int distL = ticks;
	bool driveRAtDest = false;
	bool driveLAtDest = false;

	while (!driveRAtDest && !driveLAtDest)
	{
			setRightMotors(sgn(ticks) * 127 * DRIVE_CONV_R);
			distR = ticks - SensorValue[rightQuad];
			driveRAtDest = fabs(distR) > DRIVE_EN;

			setLeftMotors(sgn(ticks) * 127 * DRIVE_CONV_L);
			distL = ticks - SensorValue[leftQuad];
			driveLAtDest = fabs(distL) > DRIVE_EN;
	}

	setAllDriveMotors(0);
}

/**
Turns the robot by a number of ticks and does not proportionally decrease motor power
@param ticks - distance in encoder ticks
@param dir - direction to turn
!warning - drives at max power until it reaches destination: could stall motors
*/
void turnBasic(int ticks, string dir)
{
	initEn();

	int dist = ticks;
	bool atDestination = false;

	/*
	While the robot has not reached its destination
	- update loop variables
	- proportionally decrease motor powers
	*/
	while (!atDestination)
	{
		if (dir == "left") { // if turning left => update right motors
			setRightMotors(127);
			setLeftMotors(-127);
			dist = ticks - SensorValue[rightQuad];
		}
		else { // if turning right => update left motors
			setLeftMotors(127);
			setRightMotors(-127);
			dist = ticks - SensorValue[leftQuad];
		}
		atDestination = dist > DRIVE_EN;
	}

	setAllDriveMotors(0); // clean
}
/**
Sets mobile base lift motor(s) to a power.
@param liftPower - a power.
*/
void setMobileBaseLiftPower(int pwr)
{
	motor[mobileBaseLiftLeft] = pwr;
	motor[mobileBaseLiftRight] = pwr;
}
/**
Sets main lift motor(s) to a power
@param liftPower - a power.
*/
void setMainLiftPower(int liftPower)
{
	motor[mainLiftLeft] = -liftPower; // fix so motors aren't going against each other
	motor[mainLiftRight] = (int) (ML_CONV * liftPower); // fix because 1 side of lift goes faster than the other
}
/**
Sets main lift to a position while proportionally decreasing motor power as lift reaches desired position
@param liftPos - a position
*/
void mlToPosBasic(int pos)
{
	int curr = SensorValue[mainLiftPot]; // current potentiometer value
	int dist = pos - curr; // distance to travel.. if negative, lift has to move down; if positive, lift has to move up
	bool ML_AtDest = false;

	while (!ML_AtDest)
	{
		setMainLiftPower(127 * sgn(dist) * ML_CONV); // must set direction based on whether lift must go up or down
		curr = SensorValue[mainLiftPot];
		dist = pos - curr;
		ML_AtDest = fabs(dist) > LIFT_POT;
	}

	setMainLiftPower(0); // clean
}
/*
Task version of function mlToPosBasic()
*/
task mlToPos()
{
	mlToPosBasic(liftPos);
}
/**
Task to move mobile base lift out while driving
*/
task mblOut()
{
	setMobileBaseLiftPower(MBL_CONV * 127);
	wait1Msec(wait);
	setMobileBaseLiftPower(0);
}
/**
Task to move mobile base lift in while driving
*/
task mblIn()
{
	setMobileBaseLiftPower(MBL_CONV * -127);
	wait1Msec(wait);
	setMobileBaseLiftPower(0);
}
/**
Sets pincer motor(s) to a power
@param pincerPower - power to set the pincer motors to
*/
void setPincerPower(int pincerPower)
{
	motor[pincers] = pincerPower;
}
/**
Sets pincer to a position while decreasing motor power
@param pincerPos - a position
*/
void setPincersToPos(int pincerPos)
{

}
/**
Drives for some distance but also moves main lift up/down at the same time
Main use in autonomous/programming skills because it may cut down time
@param ticks - distance for drive encoders in ticks
@param ML_stop - stop point for moving the lift up/out of the way
*/
void driveAndRaiseLift(int ticks, int ML_stop)
{
	liftPos = ML_stop;
	startTask(mlToPos);
	driveBasic(ticks);
}
/**
Runs autonomous
@param - string side
*/
void runMblAuton(string side)
{
	clearTimer(T1);
	string dir = "";
	// reverse
	driveBasic(-565);
	// get main lift out of the way
	liftPos = -1;
	startTask(mlToPos);
	// put MBL down
	wait = 250;
	startTask(mblOut);
	// pick up mobile goal
	wait = 750;
	startTask(mblIn);
	driveBasic(-60);
	// drive forward
	driveBasic(575);
	// get wall clearance
	turnBasic(125, side);
	driveBasic(125);
	// turn/move into pos to score
	if (side == "left")
		dir = "right";
	else if (side == "right")
		dir = "left";
	turnBasic(1050, dir);
	driveBasic(-500);
	// get main lift out of the way
	liftPos = -1;
	startTask(mlToPos);
	// raise MBL to score and reverse (at least 10 point, hopefully 20)
	wait = 750;
	startTask(mblOut);
	driveBasic(-500);
	writeDebugStreamLine("autonomous time: %d:", time1[T1]);
}

void runConeAuton(string side)
{

}

/**
Runs programming skills
*/
void runProgrammingSkills()
{
	string side = "left";
	runMblAuton(side);
}

void pre_auton()
{

}

task autonomous()
{
	string side = "left";
	runMBLauton(side);
}

task usercontrol()
{
	while(true)
	{
		// Joysticks
		int  rightJoy = vexRT[Ch2]; // right joystick
		int  leftJoy = vexRT[Ch3]; // left joystick
		// Buttons
		word btn8UP = vexRT[Btn8U]; // button raise mobile base lift
		word btn8DOWN = vexRT[Btn8D]; // button to lower mobile base lift
		// Triggers
		word rightTriggerUP = vexRT[Btn6U]; // trigger to raise main lift
		word rightTriggerDOWN = vexRT[Btn6D]; // trigger to lower main lift
		word leftTriggerUP = vexRT[Btn5U]; // trigger to open pincers
		word leftTriggerDOWN = vexRT[Btn5D]; // trigger to close pincers

		// Drive Control
		if(fabs(leftJoy) > (float) JOY) {
			setLeftMotors(DRIVE_CONV_L * leftJoy);
		}
		else {
			setLeftMotors(0);
		}

		if(fabs(rightJoy) > (float) JOY) {
			setRightMotors(DRIVE_CONV_R * rightJoy);
		}
		else {
			setRightMotors(0);
		}

		// Mobile base lift control -> change to proportional set...Pos() when ready; use "set..Power" for testing
		if(btn8UP == 1) {
			setMobileBaseLiftPower(127);
			//setMobileBaseLiftToPos(posMBLU);
		}
		else if(btn8DOWN == 1) {
			setMobileBaseLiftPower(-127);
			//setMobileBaseLiftToPos(posMBLD);
		}
		else {
			setMobileBaseLiftPower(0);
		}

		// Main lift control -> change to proportional set...Pos() when ready; use "set..Power" for testing

		if(rightTriggerUP == 1) {
			setMainLiftPower(127);
			//setMainLiftToPos(posMLU);
		}
		else if(rightTriggerDOWN == 1) {
			setMainLiftPower(-127);
			//setMainLiftToPos(posMLD);
		}
		else {
			setMainLiftPower(0);
		}

		// Pincer control -> change to proportional set...Pos() when ready;1 use "set..Power" for testing
		if(leftTriggerUP == 1) {
			setPincerPower(100);
			//setPincersToPos(PIN_O);
		}
		else if(leftTriggerDOWN == 1) {
			setPincerPower(-100);
			//setPincersToPos(PIN_C);
		}
		else {
			setPincerPower(0);
		}

	}
}
