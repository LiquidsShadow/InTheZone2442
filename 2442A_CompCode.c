#pragma config(Sensor, in2,    mainLiftPot,    sensorPotentiometer)
#pragma config(Sensor, in3,    pincerPot,      sensorPotentiometer)
#pragma config(Sensor, dgtl9,  leftQuad,       sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightQuad,      sensorQuadEncoder)
#pragma config(Motor,  port1,           mobileBaseLiftRight, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mobileBaseLiftLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftPincer,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           mainLiftRight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mainLiftLeft,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           driveLeftBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           driveLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveRightFront, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           driveRightBack, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          rightPincer,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

static const float ML_CONV = 0.85; // Main Lift Conversion
static const float MBL_CONV = 0.15; // Mobile Base Lift Conversion
static const float PINC_CONV = 0.625; // Pincer Conversion
static const float DRIVE_R_CONV = 0.65; // Drive Reduction Conversion
static const float DRIVE_CONV_R = 1.0; // Right Drive Conversion - for prop drive ctrl
static const float DRIVE_CONV_L = 1.0; // Left Drive Conversion - for prop drive ctrl
static const float DRIVE_T_CONV = 1.0; // Drive Turning Conversion
static const int DRIVE_EN = 10; // Drive Encoder buffer zone
static const int LIFT_POT = 5; // Lift Poten buffer zone
static const int PINC_POT = 10; // Pincer Poten buffer zone
static const int JOY = 15; // Joystick dead zone
static const int MLU = 3950; // main lift up
static const int MLS = 250; // main lift suspended
static const int MLD = 75; // main lift down
static const int MBLU = 0; // mbl up
static const int MBLD = 0; // mbl down
static const int PIN_O = 975; // pincer open
static const int PIN_HC = 0; // pincer hold cone
static const int PIN_C = 325; // pincer closed

static int liftPos = 0; // Global Variable for use in lift task
static int pincerPos = 0; // Global Variable for use in pincer task
static int wait = 0; // Global Variable for use in mobile base lift task

/**
Sets left drive motors to a power.
@param pwr -	a power
*/
void setLeftMotors(int pwr) {
	motor[driveLeftBack] = pwr;
	motor[driveLeftFront] = pwr;
}
/**
Sets right drive motors to a power.
@param pwr - a power
*/
void setRightMotors(int pwr) {
	motor[driveRightBack] = pwr;
	motor[driveRightFront] = pwr;
}
/**
Sets both right and left motors to a power.
@param pwr - a power
*/
void setAllDriveMotors(int pwr) {
	setLeftMotors(pwr);
	setRightMotors(pwr);
}
/**
Sets drive encoders to 0.
*/
void initEn() {
	SensorValue[leftQuad] = 0;
	SensorValue[rightQuad] = 0;
}
/**
Drives for a distance and goes from 127 -> 0
@param ticks - distance in encoder ticks
- If ticks < 0 => reverse
- If ticks > 0 => forwards
!warning - drives at max power until it reaches destination: could stall motors
*/
void drive(int ticks) {
	initEn();
	bool driveRAtDest = false;
	bool driveLAtDest = false;

	while (!driveRAtDest && !driveLAtDest)
	{
		int distR = ticks - SensorValue[rightQuad];
		int pwrR = sgn(ticks) * 127;
		//int pwrR = sgn(ticks) * distR * DRIVE_CONV_R;
		setRightMotors(pwrR);
		driveRAtDest = fabs(distR) <= DRIVE_EN;

		int distL = ticks - SensorValue[leftQuad];
		int pwrL = sgn(ticks) * 127;
		//int pwrL = sgn(ticks) * distL * DRIVE_CONV_L;
		setLeftMotors(sgn(ticks) * 127 * DRIVE_R_CONV);
		driveLAtDest = fabs(distL) <= DRIVE_EN;
	}

	setAllDriveMotors(0);
}
/**
Turns the robot by a number of ticks and does not proportionally decrease motor power
@param ticks - distance in encoder ticks
@param dir - direction to turn
!warning - drives at max power until it reaches destination: could stall motors
*/
void turn(int ticks, string dir) {
	initEn();
	bool atDestination = false;

	/*
	While the robot has not reached its destination
	- update loop variables
	- proportionally decrease motor powers
	*/
	while (!atDestination)
	{
		int dist = 0;
		int pwr = 0;
		if (dir == "left") { // if turning left => update right motors
			dist = ticks - SensorValue[rightQuad];
			//pwr = dist * DRIVE_T_CONV;
			pwr = 127;
			setRightMotors(pwr);
			setLeftMotors(-pwr);
		}
		else { // if turning right => update left motors
			dist = ticks - fabs(SensorValue[leftQuad]);
			//pwr = dist * DRIVE_T_CONV;
			pwr = 127;
			setLeftMotors(pwr);
			setRightMotors(-pwr);
		}
		atDestination = fabs(dist) <= DRIVE_EN;
	}

	setAllDriveMotors(0); // clean
}
/**
Sets mobile base lift motor(s) to a power.
@param liftPower - a power.
*/
void setMobileBaseLiftPower(int pwr) {
	motor[mobileBaseLiftLeft] = pwr;
	motor[mobileBaseLiftRight] = pwr;
}
/**
Task to move mobile base lift out while driving
*/
task mblDown() {
	setMobileBaseLiftPower(-127);
	wait1Msec(wait);
	setMobileBaseLiftPower(0);
}
/**
Task to move mobile base lift in while driving
*/
task mblUp() {
	wait1Msec(1500);
	setMobileBaseLiftPower(127);
	wait1Msec(wait);
	setMobileBaseLiftPower(0);
}
/**
Drives for some distance and moves mobile base lift in
@param ticks - distance for drive
@param wait - mbl wait
*/
void driveAndPutMblUp(int ticks, int wt) {
	wait = wt;
	startTask(mblUp);
	/*
	wait1Msec(1500);
	setMobileBaseLiftPower(127);
	wait1Msec(wait);
	setMobileBaseLiftPower(0);
	*/
	drive(ticks);
}
/**
Drives for some distance and moves mobile base lift out
@param ticks - distance for drive
@param wait - mbl wait
*/
void driveAndPutMblDown(int ticks, int wt) {
	wait = wt;
	startTask(mblDown);
	drive(ticks);
}
/**
Sets main lift motor(s) to a power
@param liftPower - a power.
*/
void setMainLiftPower(int liftPower) {
	motor[mainLiftLeft] = -liftPower; // fix so motors aren't going against each other
	motor[mainLiftRight] = (int) (ML_CONV * liftPower); // fix because 1 side of lift goes faster than the other
}
/**
Sets main lift to a position while proportionally decreasing motor power as lift reaches desired position
@param liftPos - a position
*/
void setMlToPos(int pos) {
	int dist = pos - SensorValue[mainLiftPot];

	if (fabs(dist) > LIFT_POT)
	{
		int pwr = -dist * ML_CONV;
		setMainLiftPower(pwr);
	}
	else
	{
		setMainLiftPower(0);
	}
}
/**
Task version of function mlToPosBasic()
*/
task mlUp() {
	setMainLiftPower(127);
	wait1Msec(wait);
	setMainLiftPower(0);
}
/**
Drives for some distance but also moves main lift up/down at the same time
Main use in autonomous/programming skills because it may cut down time
@param ticks - distance for drive encoders in ticks
@param ML_stop - stop point for moving the lift up/out of the way
*/
void driveAndRaiseLift(int ticks, int w) {
	wait = w;
	startTask(mlUp);
	drive(ticks);
}
/**
Sets pincer motor(s) to a power
@param pincerPower - power to set the pincer motors to
*/
void setPincerPower(int pincerPower) {
	motor[leftPincer] = pincerPower;
	motor[rightPincer] = pincerPower;
}
/**
Sets pincer to a position
@param pincerPos - a position
*/
void setPinToPos(int pos) {
	int dist = pos - SensorValue[pincerPot];

	if (fabs(dist) > PINC_POT)
	{
		int pwr = -dist * PINC_CONV;
		setPincerPower(pwr);
		//writeDebugStreamLine("basicPincToPos(); dist: %i", dist);
		//writeDebugStreamLine("basicPincToPos(); pwr: %i", pwr);
	}
	else {
		setPincerPower(0); // clean
	}
}
/**
Task version of function pincToPosBasic()
*/
task pincToPos() {
	setPinToPos(pincerPos);
}
/**
Runs mobile base lift autonomous
[START] Robot with mbl facing out on left edge of 10 point boundary
@param - string side
*/
void runMblAuton(string side) {
	clearTimer(T1);
	string dir = "";
	pincerPos = 600;
	startTask(pincToPos);
	// reverse and get main lift out of the way
	driveAndRaiseLift(-150, 350);
	// drive and put MBL down
	driveAndPutMblDown(-450, 1800);
	// pick up mobile goal
	driveAndPutMblUp(-450, 3000);
	// drive forward
	drive(450);
	// get wall clearance
	turn(75, side);
	drive(125);
	// turn/move into pos to score
	if (side == "left")
		dir = "right";
	else if (side == "right")
		dir = "left";
	turn(200, dir);
	// get main lift out of the way
	driveAndRaiseLift(-500, 100);
	// raise MBL to score and reverse (at least 10 point, hopefully 20)
	turn(200, side);
	drive(-500);
	setMobileBaseLiftPower(-127);
	wait1Msec(wait);
	setMobileBaseLiftPower(0);
	writeDebugStreamLine("mbl autonomous time: %d:", time1[T1]);
}
/**
Runs cone autonomous
[START] Robot with main lift facing out
@param - string side
*/
void runConeAuton(string side) {
	clearTimer(T1);
	string dir = "";
	writeDebugStreamLine("cone autonomous time: %d", time1[T1]);
}
/**
Runs programming skills
*/
void runProgrammingSkills() {
	string side = "left";
	runMblAuton(side);
}
void pre_auton() {

}
task autonomous() {
	string side = "left"
	runMblAuton(side);
}
task usercontrol() {
	while(true)
	{
		int  rightJoy = vexRT[Ch2]; // right joystick
		int  leftJoy = vexRT[Ch3]; // left joystick
		word btn8UP = vexRT[Btn8U]; // button raise mobile base lift
		word btn8DOWN = vexRT[Btn8D]; // button to lower mobile base lift
		word rightTriggerUP = vexRT[Btn6U]; // trigger to raise main lift
		word rightTriggerDOWN = vexRT[Btn6D]; // trigger to lower main lift
		word leftTriggerUP = vexRT[Btn5U]; // trigger to open pincers
		word leftTriggerDOWN = vexRT[Btn5D]; // trigger to close pincers
		word btn7UP = vexRT[Btn7U];
		word btn7DOWN = vexRT[Btn7D];
		// Drive Control
		if(fabs(leftJoy) > JOY)
			setLeftMotors(DRIVE_R_CONV * leftJoy);
		else
			setLeftMotors(0);
		if(fabs(rightJoy) > JOY)
			setRightMotors(rightJoy);
		else
			setRightMotors(0);
		// Mobile base lift control -> change to proportional set...Pos() when ready; use "set..Power" for testing
		if(btn8UP == 1)
			setMobileBaseLiftPower(127);
		else if(btn8DOWN == 1)
			setMobileBaseLiftPower(-127);
		else
			setMobileBaseLiftPower(0);
		// Main lift control -> change to proportional set...Pos() when ready; use "set..Power" for testing
		if(rightTriggerUP == 1)
			setMainLiftPower(127);
			//setMlToPos(MLU);
		else if(rightTriggerDOWN == 1)
			setMainLiftPower(-127);
			//setMlToPos(MLD);
		else
			setMainLiftPower(0);
		if(leftTriggerUP == 1)
			//setPincerPower(127);
			setPinToPos(PIN_C);
		else if(leftTriggerDOWN == 1)
			//setPincerPower(-127);
			setPinToPos(PIN_O);
		else
			setPincerPower(0);
	  if(btn7UP == 1)
	  	driveAndPutMblUp(-450, 3000);
	  else if(btn7DOWN == 1)
	  	driveAndPutMblDown(-450, 1800);


	}
}
